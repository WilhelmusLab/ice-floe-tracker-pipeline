#!/usr/bin/env julia
using Pkg
Pkg.activate(joinpath(@__DIR__, "../..")) # activate project environment

using DataFrames
using Dates
using HDF5
using IFTPipeline
using PyCall
using Serialization
using ArgParse: @add_arg_table, ArgParseSettings, parse_args

function getiftversion()
    deps = Pkg.dependencies()
    iftversion = ""
    for (_, dep) in deps
        dep.is_direct_dep || continue
        dep.version === nothing && continue
        dep.name != "IceFloeTracker" && continue
        iftversion = dep.version
    end
    maj = Int(iftversion.major)
    min = Int(iftversion.minor)
    patch = Int(iftversion.patch)
    return "v$maj.$min.$patch"
end

"""
    makeh5filename(imgfname, ts)

Generate the name of the HDF5 file from the name of the source image and the estimated satellite overpass time. The name of the HDF5 file is of the form `YYYYmmddTHHMM.labeled_image.250m.h5` where `YYYYmmddTHHMM` is the estimated satellite overpass time formatted string.


"""
function makeh5filename(imgfname, ts)
    fname = Dates.format(ts, "YYYYmmddTHHMM") * "." * split(imgfname, '.'; limit=2)[end]
    return replace(fname, "truecolor" => "labeled_image", "tiff" => "h5")
end

"""
    convertcentroid!(propdf, latlondata, colstodrop)

Convert the centroid coordinates from row and column to latitude and longitude. Also drop the columns specified in `colstodrop`.
"""
function convertcentroid!(propdf, latlondata, colstodrop)
    latitude, longitude = [
        [latlondata[c][Int(round(x)), Int(round(y))]] for
        (x, y) in zip(propdf.row_centroid, propdf.col_centroid) for
        c in ["latitude", "longitude"]
    ]

    x, y = [
        [latlondata[c][Int(round(z))] for z in V] for
        (c, V) in zip(["X", "Y"], [propdf.row_centroid, propdf.col_centroid])
    ]

    propdf.latitude = latitude
    propdf.longitude = longitude
    propdf.x = x
    propdf.y = y
    dropcols!(propdf, colstodrop)
    return nothing
end

function dropcols!(df, colstodrop)
    select!(df, Not(colstodrop))
    return nothing
end

function converttounits!(propdf, latlondata, colstodrop)
    if nrow(propdf) == 0
        dropcols!(propdf, colstodrop)
        return nothing
    end
    convertcentroid!(propdf, latlondata, colstodrop)
    x = latlondata["X"]
    dx = abs(x[2] - x[1])
    convertarea(area) = area * dx^2 / 1e6
    convertlength(length) = length * dx / 1e3
    propdf.area .= convertarea(propdf.area)
    propdf.convex_area .= convertarea(propdf.convex_area)
    propdf.minor_axis_length .= convertlength(propdf.minor_axis_length)
    propdf.major_axis_length .= convertlength(propdf.major_axis_length)
    propdf.perimeter .= convertlength(propdf.perimeter)
    return nothing
end

@pyinclude(joinpath(@__DIR__, "latlon.py"))

getlatlon = py"getlatlon"

"""
    makeh5file(pathtosampleimg, resdir)

Package the results of the IceFloeTracker pipeline in `resdir` into individual HDF5 files in `resdir/hdf5-files`. 

This function expects the following files to be present in `resdir`: `filenames.jls`, `passtimes.jls`, `segmented_floes.jls`, and `floe_props.jls`. These files are generated by the `IceFloeTracker` pipeline.

# Arguments:

  * `pathtosampleimg`: Path to a sample image. This is used to extract the coordinate reference system (CRS) and the latitude and longitude coordinates of the image pixels.
  * `resdir`: Path to the directory containing the results of the IceFloeTracker pipeline.

# File structure
Each HDF5 file has the following structure:

```
ðŸ—‚ï¸ HDF5.File: (read-only) YYYYmmddTHHMM.sat.labeled_image.250m.h5
â”œâ”€ ðŸ·ï¸ contact
â”œâ”€ ðŸ·ï¸ crs
â”œâ”€ ðŸ·ï¸ fname_reflectance
â”œâ”€ ðŸ·ï¸ fname_truecolor
â”œâ”€ ðŸ·ï¸ iftversion
â”œâ”€ ðŸ·ï¸ reference
â”œâ”€ ðŸ“‚ floe_properties
â”‚  â”œâ”€ ðŸ·ï¸ Description of labeled_image
â”‚  â”œâ”€ ðŸ·ï¸ Description of properties
â”‚  â”œâ”€ ðŸ”¢ column_names
â”‚  â”œâ”€ ðŸ”¢ labeled_image
â”‚  â””â”€ ðŸ”¢ properties
â””â”€ ðŸ“‚ index
   â”œâ”€ ðŸ”¢ latitude
   â”œâ”€ ðŸ”¢ longitude
   â”œâ”€ ðŸ”¢ time
   â”œâ”€ ðŸ”¢ x
   â””â”€ ðŸ”¢ y
```
# The `floe_properties` and `index` group

The `floe_properties` group contains a floe properties matrix `properties` for `labeled_image` and associated `column_names`.
The 'index' group contains the spatial coordinates in the source image coordinate reference system (default NSIDC polar stereographic, meters) and geographic coordinates (latitude and longitude, decimal degrees). Estimated satellite overpass time 'time' is provided in Unix time (seconds since 1970-01-01 00:00 UTC).
"""
function makeh5file(pathtosampleimg, resdir)
    latlondata = getlatlon(pathtosampleimg)

    iftversion = getiftversion()

    ptpath = joinpath(resdir, "passtimes.jls")
    passtimes = deserialize(ptpath)
    ptsunix = Int64.(Dates.datetime2unix.(passtimes))

    fnpath = joinpath(resdir, "filenames.jls")
    truecolor_refs, reflectance_refs = deserialize(fnpath)

    floespath = joinpath(resdir, "segmented_floes.jls")
    floes = deserialize(floespath)

    colstodrop = [:row_centroid, :col_centroid, :min_row, :min_col, :max_row, :max_col]
    propspath = joinpath(resdir, "floe_props.jls")
    props = deserialize(propspath)
    for df in props
        converttounits!(df, latlondata, colstodrop)
    end

    h5dir = joinpath(resdir, "hdf5-files")
    mkpath(h5dir)
    for (i, fname) in enumerate(truecolor_refs)
        fname = makeh5filename(fname, passtimes[i])
        fnamepath = joinpath(h5dir, fname)
        h5open(fnamepath, "w") do file
            # Add top-level attributes
            attrs(file)["fname_reflectance"] = reflectance_refs[i]
            attrs(file)["fname_truecolor"] = truecolor_refs[i]
            attrs(file)["iftversion"] = iftversion
            attrs(file)["crs"] = latlondata["crs"]
            attrs(file)["reference"] = "https://doi.org/10.1016/j.rse.2019.111406"
            attrs(file)["contact"] = "mmwilhelmus@brown.edu"

            g = create_group(file, "index")
            g["time"] = ptsunix[i]
            g["x"] = latlondata["X"]
            g["y"] = latlondata["Y"]
            g["latitude"] = latlondata["latitude"]
            g["longitude"] = latlondata["longitude"]

            g = create_group(file, "floe_properties")
            g["properties"] = Matrix(props[i])
            attrs(g)["Description of properties"] = """Generated using the `regionprops` function from the `skimage` package. See https://scikit-image.org/docs/0.20.x/api/skimage.measure.html#regionprops

            Area units (`area`, `convex_area`) are in sq. kilometers, length units (`minor_axis_length`, `major_axis_length`, and `perimeter`) in kilometers, and `orientation` in radians (see the description of properties attribute.) Latitude and longitude coordinates are in degrees, and the stereographic coordinates`x` and `y` are in meters relative to the NSIDC north polar stereographic projection.
            """

            g["column_names"] = names(props[i])
            g["labeled_image"] = label_components(floes[i], trues(3, 3))
            attrs(g)["Description of labeled_image"] = "Connected components of the segmented floe image using a 3x3 structuring element. The property matrix consists of the properties of each connected component."
        end
    end
    return nothing
end

function parse_commandline()
    settings = ArgParseSettings()

    @add_arg_table settings begin
        "--pathtosampleimg", "-p"
        help = "Path to a sample image with coordinate reference system (CRS) and latitude and longitude coordinates of image pixels"
        arg_type = String

        "--resdir", "-r"
        help = "Path to the directory containing the results of the IceFloeTracker pipeline"
        arg_type = String
    end

    return parse_args(settings; as_symbols=true)
end

function main()
    # Parse command line arguments
    args = (; parse_commandline()...)
    for (k, v) in zip(keys(args), args)
        @info "$(lpad(k, 8)) =>  $v"
    end

    pathtosampleimg = args.pathtosampleimg
    resdir = args.resdir

    makeh5file(pathtosampleimg, resdir)

    @info "h5 files written to $(resdir)"
    @info "Run completed successfully"
end

main()
